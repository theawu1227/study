**生成器对象，实际上就是迭代器**

*迭代器协议*

__ iter __,返回迭代器对象自身
__ next __, 每次返回一个迭代器数据如果没有 数据，则要抛出Stop---异常

*yield*

yield -- 改变了函数的性质
    调用生成器函数，并不是直接执行函数里的代码，而是返回一个对象。
    生成器函数内的代码，需要通过生成器对象来执行（这一点与class相似）


**生成器的四个状态**

1. 当调用生成器函数得到生成器对象时
        此时可以理解为处于初始状态
2. 通过next()调用生成器对象，对应的生成器函数代码开始运行
        此时生成器对象处于运行中状态
3. 如果遇到了yield语句，next返回时
        yield右边的对象，会作为返回值
        生成器在yield语句所在位置暂停，当再次使用next()时，继续从该位置继续运行
4. 如果执行到函数结束，则抛出Stop异常
        此时，生成器对象处于结束状态

## 生成器为什么可以变成协程
### 生成器和其他函数的区别

**函数**

每当一个函数被创建时，都会生成一个函数对象

函数中的代码则保存在代码对象中，随着函数对象一起被创建

两者保存了函数的基本信息，当函数运行时，还需要一个对象来保存运行时的状态
这个对象就是帧对象

每调用一次函数，都会创建一次帧对象，已记录当次运行的状态。
每次结束之后，都会自动销毁回收

函数之间的调用关系：先执行的后退出
同理，帧对象之间的关系也是先进后出，符合栈的数据结构
因此，函数的运行帧又被称为栈帧。
tips: 一个线程只有一个函数运行栈

**生成器函数**

生成器函数依旧是一个生成器对象，也会产生代码对象
但是调用生成器不会直接运行，这也就意味着生成器函数不会像普通函数一样创建帧对象，并压入函数栈
而是得到一个生成器对象，这个生成器对象中自带了一个帧对象
每次对生成器进行迭代的时候，生成器都会用它自带的帧对象保存当前的状态
每次迭代用的都是同一个帧.

